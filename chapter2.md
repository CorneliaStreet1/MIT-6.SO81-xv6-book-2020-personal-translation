# 第二章

# 操作系统架构

对一个操作系统的一个关键要求是能够一次支持多个活动。例如，使用第一章所描述的系统调用接口，一个进程可以通过`fork`来启动一个新的进程。操作系统必须在这些进程中分时共享计算机的资源。例如，即使计算机中现有的进程比硬件CPU的数量还多，操作系统还是必须确保所有的进程都能有一个执行程序（执行指令）的机会。操作系统同样必须安排好进程间的`隔离`。也就是说，如果某一个进程有一个bug并且发生了故障，它不应该影响到那些不依赖	这个发生故障的进程 	来运行的进程。完全的隔离，然而，强度太大了，因为我们应该保证发生在进程间的有目的的交互是有可能的，管道就是一个例子。所以一个操作系统必须满足以下要求：复用硬件，隔离，以及交互。

这一章提供了一个关于操作系统是如何组织起来以满足上述三个要求的概览。事实证明有许多的方法来达成这个目的，但这个文本主要专注于主流的以`宏内核`为中心的设计，这种设计被应用在许多Unix操作系统上。这一章同样提供了关于一个xv6进程的概览，介绍xv6的隔离单元(Unit of Isolation)，以及当xv6启动时第一个进程是如何被创造出来的。

Xv6运行在一个多核的RISC-V微处理器上，并且它的底层功能的许多部分（比如，它的进程实现）是针对(specific to)RISC-V的。RISC-V是一个64位的CPU，同时xv6由”LP64C”写成（Long and Pointers in the C programing language are 64 bits，but int is 32-bit)。本书假定读者已有一定的在某些架构上机器级别编程的经历，并且会逐渐的介绍针对RISC-V的思想。一本有用的参考书：*The RISC-V Reader : An Open Architecture Atlas*

在一个完整的计算机中的CPU会被支持性硬件包围，其中的许多部分以I/O接口的形式存在。Xv6被写出来用于被qemu的"-machine virt"选项模拟出来的支持硬件上。这包括RAM，一个包含启动代码（引导代码？boot code）的ROM，一系列与用户键盘与屏幕的连接，以及一个用于存储的硬盘。

```c
//还有一些注释没翻译
```

## 2.1	抽象物理资源

当一个人遇见操作系统的时候，他可能会问的第一个问题是，为什么需要这些东西？那是因为，一个人可以以库的形式在Figure 1.2中实现系统调用，应用程序们则和库绑定在一起。在这个计划中， 每个应用甚至可以拥有为自身需求订制的专属库。应用程序可以直接与硬件资源交互并且用以对自己最有利的方式使用这些资源（例如，达到更高的性能表现或者可预测的表现）。一些嵌入式设备的操作系统或者是实时操作系统就是这样组织的。

这使用库的方法的消极之处在于，如果有多于一个应用程序正在运行，这些应用程序必须要性能良好。例如，每一个应用程序都必须符合预期的让出CPU以让其他的应用程序得以运行。这样的一个协作性的分时方案（time-sharing scheme）也许是可行的，如果所有的应用程序信任彼此并且都不存在bug。更典型的情况其实是应用程序们彼此不相互信任，并且还有bug的存在。所以大家还是经常更想要更强的隔离，而没有那么想要协作体系。

禁止应用程序直接访问敏感的硬件资源有助于达到强壮的隔离的目的，相反（instead）我们将资源抽象成服务。例如，Unix的应用程序只通过文件系统的`open`，`read`，`write`和`close`系统调用来与存储交互，而不是直接在硬盘上读写。这给应用程序提供了路径名称的便利，并且它允许操作系统（作为接口的实施者，implementer）管理硬盘。就算不是为了隔离，有目的地交互的程序们（或者只是为了防止自己挡别人的路）也很可能发现文件系统是比直接使用硬盘更方便的抽象。

相似的是，Unix在进程间透明的转换硬件CPU，在必要时保存和恢复寄存器状态，使得应用程序没有必要知道分时共享（应用程序实际上不会意识到自己是分时段使用CPU的，会以为自己一直在使用CPU）。这种透明性运行操作系统在应用程序间共享CPU，即使某些应用程序处于无限循环之中。

作为另外一个例子，Unix进程使用`exec`来建立他们的内存镜像，而不是直接与物理内存交互。这使得操作系统得以决定在内存的哪个地方放置一个进程；如果内存紧张，操作系统可能甚至会将进程的某些数据存储在硬盘上。`Exec`还给用户提供了使用文件系统来存储可执行程序镜像的便利性。

Unix进程中许多形式的交互都借助文件描述符发生。文件描述符不仅抽离了许多细节（例如，文件是在管道还是存储在硬盘的某处），它们还以一种简化交互的方式定义的。例如，如果管道中的应用出错了，内核生成一个EOF信号给管道的下一个进程。

Figure1.2中的系统调用接口经过精心设计以给程序员提供便利的同时保证健壮的隔离的可能性。Unix接口并不是抽象资源的唯一方式，但它已经被证明是极其优秀的一种。

## 2.2	用户模式 ，监管模式，以及系统调用

健壮的隔离要求一个难以逾越的界限存在于应用程序和操作系统之间。如果应用程序发生了一个错误，我们不想操作系统或者其他程序也出错(fail)。相反，操作系统应该能够清理掉出错的应用程序并且继续运行其他应用程序。为了达到强壮的隔离，操作系统必须使得应用程序无法编辑（甚至读取）操作系统的数据结构以及指令，以及应用程序无法访问其他进程的内存。

CPU给强隔离提供了硬件支持。例如，RISC-V有三种CPU执行指令的模式：机器模式，监管模式（supervisor mode）以及用户模式。机器模式下执行的指令拥有完全的权限；CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6在机器模式下执行一些指令然后转换到监管模式。

在监管模式下CPU被许可执行拥有权限的指令：例如，启用以及关闭中断，读写保存了页表地址的寄存器，等等。如果一个处于用户模式下的应用程序试图执行一条拥有权限的指令，那么CPU将不会执行那条指令，但会转换到监管者模式，从而监管者模式代码可以终止应用程序，因为它做了一些它不应该做的事情。在第一章中的Figure1.1解释了这种组织。一个应用程序只能执行用户模式的指令（例如加入数字等等），并且被称作运行在用户空间，对比之下处于监管者模式的软件还可以执行有权限的指令，并且被称作运行在内核空间中。运行在内核空间（或者说处于监管者模式）的软件被称作内核。

一个想要调用内核函数（例如Xv6中的read系统调用）的应用程序必须跳转到内核去。CPU提供了一个特殊的指令，这个指令将CPU由用户模式转换到监管模式并且在由内核指定的入口点进入内核（RISC-V为这个目的提供了ecall指令）。一旦CPU进入了监管模式，然后内核就可以验证系统调用的参数，决定应用程序是否被允许执行被要求的操作，然后拒绝操作或者是执行操作。内核控制过渡到监管者模式的入口点十分重要；如果应用程序可以决定内核入口点，那么一个恶意程序就可以在参数验证被跳过的时候进入内核。

## 2.3	内核组织结构

一个关键的设计性问题是操作系统的哪一部分应该在监管模式下运行。一种可能性是整个操作系统都置于内核中，那么所有系统调用的实现都在监管模式下运行。这种组织结构叫做`宏内核`。

在这种组织结构下整个操作系统运行时具有完整的硬件权限。这种组织结构很方便，因为操作系统的设计者不需要决定操作系统的哪一部分不需要完整的硬件权限。进一步来说，操作系统的不同部分协作起来更加容易。例如，一个操作系统可以有一个同时被文件系统和虚拟内存系统共享的缓冲区。

宏内核的一个消极之处在于，介于操作系统不同部分间的的接口经常是很复杂的（我们将会在文本接下来的内容中见识到这一点），所以操作系统开发者就很容易犯错。在一个宏内核中，一个错误是致命的，因为监管模式的一个出错往往会导致内核出错（fail）。如果内核出错，计算机就会停止工作，于是所有的应用程序都出故障了。计算机必须重启以重新开始工作。

![屏幕截图 2021-09-24 180222](D:\6.S081 Fall 2020\MIT-6.SO81-xv6-book-2020-personal-translation\pic\屏幕截图 2021-09-24 180222.png)

为了减少内核出错的概率，操作系统设计者可以缩小在监管模式中运行的操作系统的代码数量，在用户模式下运行操作系统的主体。这种内核架构称作微内核。

Figure2.1图示了这种微内核设计。在图中，文件系统作为一个用户级别的进程运行。OS服务作为进程运行被称作服务器(servers)。为了运行应用程序与文件服务器交互，内核提供了一个进程间的通信机制来从一个处于用户模式的进程发送信息给另一个。例如，如果一个应用程序比如shell想要读或写一个文件，它给文件服务器发送一个信息然后等待一个回应。

在微内核中，内核接口由一些用来启动应用程序、发送信息、访问设备硬件等等的低层级函数组成。这种架构使得内核可以相对简单，因为大部分的操作系统处于用户层的服务器中。

Xv6是作为宏内核实现的，像大部分的Unix操作系统一样。所以，xv6的内核接口相当于操作系统接口，同时内核实现了完整的操作系统。因为xv6不提供太多的服务，它的内核比某些微内核还小，但概念上来说xv6还是一个宏内核。
