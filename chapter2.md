# 第二章

# 操作系统架构

对一个操作系统的一个关键要求是能够一次支持多个活动。例如，使用第一章所描述的系统调用接口，一个进程可以通过`fork`来启动一个新的进程。操作系统必须在这些进程中分时共享计算机的资源。例如，即使计算机中现有的进程比硬件CPU的数量还多，操作系统还是必须确保所有的进程都能有一个执行程序（执行指令）的机会。操作系统同样必须安排好进程间的`隔离`。也就是说，如果某一个进程有一个bug并且发生了故障，它不应该影响到那些不依赖	这个发生故障的进程 	来运行的进程。完全的隔离，然而，强度太大了，因为我们应该保证发生在进程间的有目的的交互是有可能的，管道就是一个例子。所以一个操作系统必须满足以下要求：复用硬件，隔离，以及交互。

这一章提供了一个关于操作系统是如何组织起来以满足上述三个要求的概览。事实证明有许多的方法来达成这个目的，但这个文本主要专注于主流的以`宏内核`为中心的设计，这种设计被应用在许多Unix操作系统上。这一章同样提供了关于一个xv6进程的概览，介绍xv6的隔离单元(Unit of Isolation)，以及当xv6启动时第一个进程是如何被创造出来的。

Xv6运行在一个多核的RISC-V微处理器上，并且它的底层功能的许多部分（比如，它的进程实现）是针对(specific to)RISC-V的。RISC-V是一个64位的CPU，同时xv6由”LP64C”写成（Long and Pointers in the C programing language are 64 bits，but int is 32-bit)。本书假定读者已有一定的在某些架构上机器级别编程的经历，并且会逐渐的介绍针对RISC-V的思想。一本有用的参考书：*The RISC-V Reader : An Open Architecture Atlas*

在一个完整的计算机中的CPU会被支持性硬件包围，其中的许多部分以I/O接口的形式存在。Xv6被写出来用于被qemu的"-machine virt"选项模拟出来的支持硬件上。这包括RAM，一个包含启动代码（引导代码？boot code）的ROM，一系列与用户键盘与屏幕的连接，以及一个用于存储的硬盘。

```c
//还有一些注释没翻译
```

## 2.1	抽象物理资源

当一个人遇见操作系统的时候，他可能会问的第一个问题是，为什么需要这些东西？那是因为，一个人可以以库的形式在Figure 1.2中实现系统调用，应用程序们则和库绑定在一起。在这个计划中， 每个应用甚至可以拥有为自身需求订制的专属库。应用程序可以直接与硬件资源交互并且用以对自己最有利的方式使用这些资源（例如，达到更高的性能表现或者可预测的表现）。一些嵌入式设备的操作系统或者是实时操作系统就是这样组织的。

这使用库的方法的消极之处在于，如果有多于一个应用程序正在运行，这些应用程序必须要性能良好。例如，每一个应用程序都必须符合预期的让出CPU以让其他的应用程序得以运行。这样的一个协作性的分时方案（time-sharing scheme）也许是可行的，如果所有的应用程序信任彼此并且都不存在bug。更典型的情况其实是应用程序们彼此不相互信任，并且还有bug的存在。所以大家还是经常更想要更强的隔离，而没有那么想要协作体系。

禁止应用程序直接访问敏感的硬件资源有助于达到强壮的隔离的目的，相反（instead）我们将资源抽象成服务。例如，Unix的应用程序只通过文件系统的`open`，`read`，`write`和`close`系统调用来与存储交互，而不是直接在硬盘上读写。这给应用程序提供了路径名称的便利，并且它允许操作系统（作为接口的实施者，implementer）管理硬盘。就算不是为了隔离，有目的地交互的程序们（或者只是为了防止自己挡别人的路）也很可能发现文件系统是比直接使用硬盘更方便的抽象。

相似的是，Unix在进程间透明的转换硬件CPU，在必要时保存和恢复寄存器状态，使得应用程序没有必要知道分时共享（应用程序实际上不会意识到自己是分时段使用CPU的，会以为自己一直在使用CPU）。这种透明性运行操作系统在应用程序间共享CPU，即使某些应用程序处于无限循环之中。

作为另外一个例子，Unix进程使用`exec`来建立他们的内存镜像，而不是直接与物理内存交互。这使得操作系统得以决定在内存的哪个地方放置一个进程；如果内存紧张，操作系统可能甚至会将进程的某些数据存储在硬盘上。`Exec`还给用户提供了使用文件系统来存储可执行程序镜像的便利性。

Unix进程中许多形式的交互都借助文件描述符发生。文件描述符不仅抽离了许多细节（例如，文件是在管道还是存储在硬盘的某处），它们还以一种简化交互的方式定义的。例如，如果管道中的应用出错了，内核生成一个EOF信号给管道的下一个进程。

Figure1.2中的系统调用接口经过精心设计以给程序员提供便利的同时保证健壮的隔离的可能性。Unix接口并不是抽象资源的唯一方式，但它已经被证明是极其优秀的一种。

## 2.2	用户模式 ，监管模式，以及系统调用

健壮的隔离要求一个难以逾越的界限存在于应用程序和操作系统之间。如果应用程序发生了一个错误，我们不想操作系统或者其他程序也出错(fail)。相反，操作系统应该能够清理掉出错的应用程序并且继续运行其他应用程序。为了达到强壮的隔离，操作系统必须使得应用程序无法编辑（甚至读取）操作系统的数据结构以及指令，以及应用程序无法访问其他进程的内存。

CPU给强隔离提供了硬件支持。例如，RISC-V有三种CPU执行指令的模式：机器模式，监管模式（supervisor mode）以及用户模式。机器模式下执行的指令拥有完全的权限；CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6在机器模式下执行一些指令然后转换到监管模式。

在监管模式下CPU被许可执行拥有权限的指令：例如，启用以及关闭中断，读写保存了页表地址的寄存器，等等。如果一个处于用户模式下的应用程序试图执行一条拥有权限的指令，那么CPU将不会执行那条指令，但会转换到监管者模式，从而监管者模式代码可以终止应用程序，因为它做了一些它不应该做的事情。在第一章中的Figure1.1解释了这种组织。一个应用程序只能执行用户模式的指令（例如加入数字等等），并且被称作运行在用户空间，对比之下处于监管者模式的软件还可以执行有权限的指令，并且被称作运行在内核空间中。运行在内核空间（或者说处于监管者模式）的软件被称作内核。

一个想要调用内核函数（例如Xv6中的read系统调用）的应用程序必须跳转到内核去。CPU提供了一个特殊的指令，这个指令将CPU由用户模式转换到监管模式并且在由内核指定的入口点进入内核（RISC-V为这个目的提供了ecall指令）。一旦CPU进入了监管模式，然后内核就可以验证系统调用的参数，决定应用程序是否被允许执行被要求的操作，然后拒绝操作或者是执行操作。内核控制过渡到监管者模式的入口点十分重要；如果应用程序可以决定内核入口点，那么一个恶意程序就可以在参数验证被跳过的时候进入内核。

## 2.3	内核组织结构

一个关键的设计性问题是操作系统的哪一部分应该在监管模式下运行。一种可能性是整个操作系统都置于内核中，那么所有系统调用的实现都在监管模式下运行。这种组织结构叫做`宏内核`。

在这种组织结构下整个操作系统运行时具有完整的硬件权限。这种组织结构很方便，因为操作系统的设计者不需要决定操作系统的哪一部分不需要完整的硬件权限。进一步来说，操作系统的不同部分协作起来更加容易。例如，一个操作系统可以有一个同时被文件系统和虚拟内存系统共享的缓冲区。

宏内核的一个消极之处在于，介于操作系统不同部分间的的接口经常是很复杂的（我们将会在文本接下来的内容中见识到这一点），所以操作系统开发者就很容易犯错。在一个宏内核中，一个错误是致命的，因为监管模式的一个出错往往会导致内核出错（fail）。如果内核出错，计算机就会停止工作，于是所有的应用程序都出故障了。计算机必须重启以重新开始工作。

![屏幕截图 2021-09-24 180222](D:\6.S081 Fall 2020\MIT-6.SO81-xv6-book-2020-personal-translation\pic\figure2.1.png)

为了减少内核出错的概率，操作系统设计者可以缩小在监管模式中运行的操作系统的代码数量，在用户模式下运行操作系统的主体。这种内核架构称作微内核。

Figure2.1图示了这种微内核设计。在图中，文件系统作为一个用户级别的进程运行。OS服务作为进程运行被称作服务器(servers)。为了运行应用程序与文件服务器交互，内核提供了一个进程间的通信机制来从一个处于用户模式的进程发送信息给另一个。例如，如果一个应用程序比如shell想要读或写一个文件，它给文件服务器发送一个信息然后等待一个回应。

在微内核中，内核接口由一些用来启动应用程序、发送信息、访问设备硬件等等的低层级函数组成。这种架构使得内核可以相对简单，因为大部分的操作系统处于用户层的服务器中。

Xv6是作为宏内核实现的，像大部分的Unix操作系统一样。所以，xv6的内核接口相当于操作系统接口，同时内核实现了完整的操作系统。因为xv6不提供太多的服务，它的内核比某些微内核还小，但概念上来说xv6还是一个宏内核。

## 2.4	代码：Xv6架构

Xv6内核的源代码在`kernel/`子目录里。源代码被分成了多个文件，大抵上遵照了模块化的观念。Figure2.2列出了文件列表。模块间的接口在`defs.h`（kernel/defs.h）中有定义。

![figure2.2](D:\6.S081 Fall 2020\MIT-6.SO81-xv6-book-2020-personal-translation\pic\figure2.2.png)

## 2.5	进程概览

在xv6中，隔离以进程为单位（在其他Unix操作系统中也如此）。进程抽离阻止了一个进程破坏或窥视另外一个进程的内存，CPU，文件描述符等等。它同样阻止了进程破坏内核本身，使得进程暗中破坏内核的隔离机制。内核必须小心翼翼的实现进程抽离，因为一个恶意应用也许会诱使内核或硬件去做坏事（例如绕过隔离）。内核用来实现进程的机制包括 用户/监管模式标志，地址空间，以及线程的时间分片。

为了落实隔离，进程抽离给应用程序一个它拥有属于自己的私有机器的假象。一个进程提供给一个应用程序看上去是私有的内存系统，或者说地址空间，其他进程无法读写。一个进程同样给这个应用程序提供看上去是属于自己的CPU来执行这个程序的指令。

Xv6使用页表（由硬件实现）来给给每个进程属于它自己的地址空间。RISC-V的页表将一个虚拟地址（RISC-V指令操控的地址）翻译（或者说映射）到一个物理地址上（CPU芯片送入主存储器（main memory）的地址）。

![figure2.3](D:\6.S081 Fall 2020\MIT-6.SO81-xv6-book-2020-personal-translation\pic\figure2.3.png)

Xv6为每一个进程维护一个独立的页表，这个页表定义了进程的地址空间。如图Figure 2.3所示，一个地址空间包括这个进程的从虚拟地址0开始的用户内存。指令最先出现，随后是全局变量，然后是栈，最后是堆（heap）内存（用来malloc），堆内存可以由进程按需扩展。有许多限制一个进程最大地址空间的因素：1.RISC-V上的指针是64位宽的；2.当硬件在页表上寻找虚拟地址时它只会使用低位的39位。所以，最大的地址是2 的38次幂减一（2 ^ 38 - 1 = 0x3fffffffff），称为MAXVA`(kernel/riscv.h:348)`。在地址空间的最顶层xv6保留了一页给trampoline，以及一页

```c
/***************************************翻译中断，存在疑问******************************/
```

Xv6内核为每个进程保留许多状态段，内核将这些汇集在一个结构内 `struct proc(kernel/proc.h:86)`。一个进程最主要的内核状态段是它的页表，它的内核栈，以及它的运行状态。我们使用记号 p ->xxx来表示proc结构的某一成员。比如，p -> pagetable 是一个指向进程页表的指针。

每一个进程有一个执行线程（简称线程）用来执行进程的指令。一个线程可以被挂起然后后来再重新启动。为了透明地在进程间转换，内核挂起当前正在运行的线程，重新启动另外一个进程的线程。线程的许多状态值（本地变量，函数调用返回地址）被存储在这个线程的栈中。每个进程有两个栈区：一个用户栈区还有一个内核栈区（p -> kstack）。当进程在执行用户指令的时候，只有其用户栈区被使用，而其内核栈区则为空。当进程进入内核（为了系统调用或者中断），内核代码在进程的内核栈执行；当进程处于内核之中时，它的用户栈仍旧存储着已保存的数据，但没有被动态地使用。一个进程的线程在动态使用它的用户栈和内核栈之间交替。内核栈是独立的（并且user code 无法访问）所以即使进程破坏了它的用户栈，内核还是可以执行。

一个进程可以通过执行RISC-V的`ecall`指令来发出一个系统调用。这个指令会提高硬件权限并且改变程序计数器到内核定义的入口点。在入口点的代码转换到内核栈然后执行实现了系统调用的内核指令。当系统调用完成，内核转换回用户栈，调用`sret`指令返回用户空间，这个指令会降低硬件权限并且继续执行恰好处于系统调用指令后面的用户指令。一个进程的线程可以在内核中“阻塞”以等待I/O，然后在I/O完成以后在它停下来的地方重新继续。

p -> state表征进程是已分配的(allocated)，准备运行(ready to run)，正在运行(running)，等待I/O，或是正在退出(exiting)。

P -> pagetable存储了进程的页表，以RISC-V硬件期望的形式。Xv6使页表硬件在用户空间执行进程时使用这个进程的p -> pagetable。一个进程的页表同样用来作为已分配的用于存储进程内存的物理页表的地址。

## 2.6	代码：启动xv6和第一个进程

为了让xv6看上去更加具体，我们将会概述内核是如何启动以及运行第一个进程的。接下来的章节将会更细节的描述在这个概览中出现的那些机制。

当RISC-V计算机启动的时候，它初始化自身并运行一个存放在只读内存的启动装载(boot loader)。启动装载器将xv6内核加载入内存中。然后，在机器模式下，CPU从`_entry`(kernel/entry.S:6)开始执行xv6。RISC-V以页表硬件不启用开始：虚拟地址直接与物理地址映射。

装载器将xv6内核加载进内存的物理地址0x80000000。装载器将内核放在物理地址0x80000000而不是0x0的原因是，从0x0到0x80000000之间存放着I/O设备。

在`_enrty`的指令建立了一个栈使得xv6可以运行C代码。Xv6为初始栈`stack0`声明空间，在文件start.c中(kernel/start.c:11)。在`_entry`的代码用地址stack0 + 4096，stack0的顶，加载入栈指针寄存器`sp`，因为在RISC-V上栈是减小的。现在内核有一个栈了，`_entry`调用处于start的C代码(kernel/start.c)。

函数`start`执行一些只允许在机器模式下执行的配置，然后转换到监管模式。为了进入监管模式，RISC-V提供了指令`mret`。这个指令最经常用于从此前由监管模式到机器模式的调用返回。`start`并不从像这样的调用返回，而是配置好一切仿佛此前已有一个调用：它在寄存器`mstatus`中将此前的权限模式设置为监管模式，将`main`的地址写入寄存器`mepc`以设置好到`main`的返回地址，通过将0写入页表寄存器`satp`停用监管模式的虚拟地址翻译，将所有的中断和异常委托给监管模式。

在跳入监管模式之前，`start`还执行了一个任务：它编写时钟芯片以生成定时器中断。做完这件事后，`start`通过调用`mret`"返回"监管模式。这使得程序计数器转换至main（kernel/main.c:11）。

在`main`（kernel/main.c:11）初始化了几个设备和子系统后，它通过调用`userinit`(kernel/proc.c:212)创建第一个进程。第一个进程执行一个由用RISC-V汇编语言写的小程序,initcode.S(user/initcode.S)，它通过调用`exec`系统调用重新进入内核。正如我们在第一章看到的，`exec`用一个新程序替代掉现有进程的内存和寄存器（在这种情况下，/init）。一旦内核完成`exec`，它返回`/init`进程中的用户空间。Init（user/init.c:15)创建一个新的控制台设备文件（如果需要），然后将它作为文件描述符0,1和2打开。然后它在控制台上启动一个shell。系统启动了。

## 2.7	真实的世界

在真实世界中，一个人可以同时找到宏内核和微内核。许多Unix内核是宏内核。例如，Linux有一个宏内核，虽然有些操作系统函数作为用户层服务运行（例如，窗口系统）。诸如L4，Minix和QNX是作为微内核和服务架构的，并且被广泛部署在嵌入式设备中。

大部分操作系统都都已经采纳了进程的概念，并且大部分的进程都看上去和xv6的很相似。现代操作系统，然而，支持一个进程中多个线程，以允许单个进程利用多个CPU。在单个进程中支持多线程涉及许多xv6不具有的机制，包括潜在的接口变更（例如，Linux的clone，`fork`的一个变种），来控制进程的哪一部分线程共享。

## 2.8	练习

不翻译了 lab里应该有吧 没有看心情补上去

第二章完结撒花 好耶！！！！！

始于：

‎2021‎年‎9‎月‎23‎日17:36:59

完结于：

2021年9月25日20:42:17
